# HTTP连接池

分析是基于go 1.13

## 为什么需要连接池

服务和服务之间的连接是开发过程中很常见的操作,为了服务解耦,减少相互依赖,增强系统稳定性,灵活性,所以会增加许许多多的服务通信链路,随着服务通信链路的增加,网络通信次数就会成倍的增长,那么随之而来的就是网络资源的消耗加剧,例如:带宽,连接数以及cpu,内存等。

- 每个连接建立时都会申请内存用来做socket buffer
- 每个连接都要做三次握手四次挥手
- 每个连接关闭时都要释放内存空间
- 并发高时,会产生大量的连接,影响系统调度,会占用太多系统资源

## 如何设计实现连接池

- 连接池的连接数目是否有限制，最大可以建立多少个连接？
- 当连接长时间没有使用，需要回收该连接吗？
- 业务请求需要获取连接时，此时若连接池无空闲连接且无法新建连接，业务需要排队等待吗？
- 排队的话又存在另外的问题，队列长度有无限制，排队时间呢？

## GoLang HTTP连接池的实现原理

### 核心结构Transport

1. Transport是实现HTTP连接请求/和连接池的核心结构，transport实现了`RoundTripper`接口， 支持HTTP、HTTPS和HTTP代理请求
2. transport的主要功能其实就是缓存了长连接，用于大量http请求场景下的连接复用，减少发送请求时TCP(TLS)连接建立的时间损耗
3. transport是协程并发安全的
4. 同时transport还能对连接做一些限制，如连接超时时间，每个host的最大连接数等。transport对长连接的缓存和控制仅限于TCP+(TLS)+HTTP1，不对HTTP2做缓存和限制。

```go
type Transport struct {
    //操作空闲连接需要获取锁
	idleMu       sync.Mutex 
	closeIdle    bool // user has requested to close all idle conns
    // *空闲连接池，key为协议目标地址等组合,最大值受maxIdleConnsPerHost限制
	idleConn     map[connectMethodKey][]*persistConn // most recently used at end
    // *等待空闲连接的队列，基于切片实现，队列大小无限制
	idleConnWait map[connectMethodKey]wantConnQueue  // waiting getConns
    // 空闲连接的LRU，用于删除最近未使用的连接
	idleLRU      connLRU

	reqMu       sync.Mutex
	reqCanceler map[*Request]func(error)

	altMu    sync.Mutex   // guards changing altProto only
	altProto atomic.Value // of nil or map[string]RoundTripper, key is URI scheme
    //排队等待建立连接需要获取锁
	connsPerHostMu   sync.Mutex
    //每个host建立的连接数
	connsPerHost     map[connectMethodKey]int
    //等待建立连接的队列，同样基于切片实现，队列大小无限制
	connsPerHostWait map[connectMethodKey]wantConnQueue // waiting getConns

	// Proxy specifies a function to return a proxy for a given
	// Request. If the function returns a non-nil error, the
	// request is aborted with the provided error.
	//
	// The proxy type is determined by the URL scheme. "http",
	// "https", and "socks5" are supported. If the scheme is empty,
	// "http" is assumed.
	//
	// If Proxy is nil or returns a nil *URL, no proxy is used.
	Proxy func(*Request) (*url.URL, error)

	/*
	 DialContext 可以控制和配置用于创建TCP连接的拨号函数，如果没有使用DialContext即DialContext为nil（并且也没有使用Dial）则会使用net包
	*/
	DialContext func(ctx context.Context, network, addr string) (net.Conn, error)

	// Dial specifies the dial function for creating unencrypted TCP connections.
	//
	// Dial runs concurrently with calls to RoundTrip.
	// A RoundTrip call that initiates a dial may end up using
	// a connection dialed previously when the earlier connection
	// becomes idle before the later Dial completes.
	//
	// Deprecated: Use DialContext instead, which allows the transport
	// to cancel dials as soon as they are no longer needed.
	// If both are set, DialContext takes priority.
	Dial func(network, addr string) (net.Conn, error)

	// DialTLS specifies an optional dial function for creating
	// TLS connections for non-proxied HTTPS requests.
	//
	// If DialTLS is nil, Dial and TLSClientConfig are used.
	//
	// If DialTLS is set, the Dial hook is not used for HTTPS
	// requests and the TLSClientConfig and TLSHandshakeTimeout
	// are ignored. The returned net.Conn is assumed to already be
	// past the TLS handshake.
	DialTLS func(network, addr string) (net.Conn, error)

	// TLSClientConfig specifies the TLS configuration to use with
	// tls.Client.
	// If nil, the default configuration is used.
	// If non-nil, HTTP/2 support may not be enabled by default.
	TLSClientConfig *tls.Config

	// TLSHandshakeTimeout specifies the maximum amount of time waiting to
	// wait for a TLS handshake. Zero means no timeout.
	TLSHandshakeTimeout time.Duration

	//禁用长连接，使用短连接
	DisableKeepAlives bool

	// DisableCompression, if true, prevents the Transport from
	// requesting compression with an "Accept-Encoding: gzip"
	// request header when the Request contains no existing
	// Accept-Encoding value. If the Transport requests gzip on
	// its own and gets a gzipped response, it's transparently
	// decoded in the Response.Body. However, if the user
	// explicitly requested gzip it is not automatically
	// uncompressed.
	DisableCompression bool

	// 最大空闲连接数
	MaxIdleConns int

	//每个目标host最大空闲连接数；默认为2（注意默认值= DefaultMaxIdleConnsPerHost）
	MaxIdleConnsPerHost int

	// 每个host可建立的最大连接数 包含空闲的、正在连接的和已经连接的，0代表没有限制
	MaxConnsPerHost int

	// 空闲连接多少时间没有使用则被关闭
	// Zero means no limit.
	IdleConnTimeout time.Duration

	// ResponseHeaderTimeout, if non-zero, specifies the amount of
	// time to wait for a server's response headers after fully
	// writing the request (including its body, if any). This
	// time does not include the time to read the response body.
	ResponseHeaderTimeout time.Duration

	// ExpectContinueTimeout, if non-zero, specifies the amount of
	// time to wait for a server's first response headers after fully
	// writing the request headers if the request has an
	// "Expect: 100-continue" header. Zero means no timeout and
	// causes the body to be sent immediately, without
	// waiting for the server to approve.
	// This time does not include the time to send the request header.
	ExpectContinueTimeout time.Duration

	// TLSNextProto specifies how the Transport switches to an
	// alternate protocol (such as HTTP/2) after a TLS NPN/ALPN
	// protocol negotiation. If Transport dials an TLS connection
	// with a non-empty protocol name and TLSNextProto contains a
	// map entry for that key (such as "h2"), then the func is
	// called with the request's authority (such as "example.com"
	// or "example.com:1234") and the TLS connection. The function
	// must return a RoundTripper that then handles the request.
	// If TLSNextProto is not nil, HTTP/2 support is not enabled
	// automatically.
	TLSNextProto map[string]func(authority string, c *tls.Conn) RoundTripper

	// ProxyConnectHeader optionally specifies headers to send to
	// proxies during CONNECT requests.
	ProxyConnectHeader Header

	// MaxResponseHeaderBytes specifies a limit on how many
	// response bytes are allowed in the server's response
	// header.
	//
	// Zero means to use a default limit.
	MaxResponseHeaderBytes int64

	// WriteBufferSize specifies the size of the write buffer used
	// when writing to the transport.
	// If zero, a default (currently 4KB) is used.
	WriteBufferSize int

	// ReadBufferSize specifies the size of the read buffer used
	// when reading from the transport.
	// If zero, a default (currently 4KB) is used.
	ReadBufferSize int

	// nextProtoOnce guards initialization of TLSNextProto and
	// h2transport (via onceSetNextProtoDefaults)
	nextProtoOnce      sync.Once
	h2transport        h2Transport // non-nil if http2 wired up
	tlsNextProtoWasNil bool        // whether TLSNextProto was nil when the Once fired

	// ForceAttemptHTTP2 controls whether HTTP/2 is enabled when a non-zero
	// Dial, DialTLS, or DialContext func or TLSClientConfig is provided.
	// By default, use of any those fields conservatively disables HTTP/2.
	// To use a custom dialer or TLS config and still attempt HTTP/2
	// upgrades, set this to true.
	ForceAttemptHTTP2 bool
}
```



参考：

https://www.cnblogs.com/charlieroro/p/11409153.html

https://studygolang.com/articles/30261

https://segmentfault.com/a/1190000023033193?utm_source=tag-newest

https://blog.csdn.net/qq_21514303/article/details/87794750

https://www.geek-share.com/detail/2708343360.html 

https://draveness.me/golang/docs/part4-advanced/ch09-stdlib/golang-net-http/#922-%E5%AE%A2%E6%88%B7%E7%AB%AF



需要搞懂的：

TIME_WAIT：https://www.cnblogs.com/rexcheny/p/11143128.html



https://segmentfault.com/a/1190000019736068



可能遇到的问题

https://blog.csdn.net/luckydoit/article/details/86510618

https://www.dazhuanlan.com/2019/12/13/5df2e64445102/

http://xiaorui.cc/archives/5056