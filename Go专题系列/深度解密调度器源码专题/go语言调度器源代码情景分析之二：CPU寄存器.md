# go语言调度器源代码情景分析之二：CPU寄存器

**寄存器是CPU内部的存储单元**，用于存放从内存读取而来的数据（包括指令）和CPU运算的中间结果，之所以要使用寄存器来临时存放数据而不是直接操作内存，**一是因为CPU的工作原理决定了有些操作运算只能在CPU内部进行，二是因为CPU读写寄存器的速度比读写内存的速度快得多**。

为了便于交流和使用汇编语言进行编程，CPU厂商为每个寄存器都取了一个名字，比如`AMD64` CPU中的`rax, rbx, rcx, rdx`等等，这样程序员就可以很方便的在汇编代码中使用寄存器的名字来进行编程，为了对寄存器的使用有个直观的感受，我们用个例子来简单的说明一下。

假设有如下go语言编写的一行代码：

```
c = a + b
```

在`AMD64` Linux平台下，使用go编译器编译它可得到如下`AT&T`格式的汇编代码（如果对汇编代码不熟悉的话可以直接看每一条指令后面的注释，不影响我们理解）：

```
mov   (%rsp),%rdx       //把变量a的值从内存中读取到寄存器rdx中
mov   0x8(%rsp),%rax   //把变量b的值从内存中读取到寄存器rax中
add   %rdx,%rax        //把寄存器rdx和rax中的值相加，并把结果放回rax寄存器中
mov   %rax,0x10(%rsp)  //把寄存器rax中的值写回变量c所在的内存
```

可以看到，上面的一行go语言代码被编译成了4条汇编指令，指令中出现的`rax`，`rdx`和`rsp`都是寄存器的名字（`AT&T`格式的汇编代码中所有寄存器名字前面都有一个%符号），虽然这里只有4条指令，但也从一个侧面说明汇编代码其实比较简单，它所做的工作不外乎就是把数据在内存和寄存器中搬来搬去或做一些基础的数学和逻辑运算。

不同体系结构的CPU，其内部寄存器的数量、种类以及名称可能大不相同，这里我们只介绍目前使用最为广泛的`AMD64`这种体系结构的CPU，这种CPU共有20多个可以直接在汇编代码中使用的寄存器，其中有几个寄存器在操作系统代码中才会见到，而应用层代码一般只会用到如下分为三类的19个寄存器。

1. **通用寄存器**：`rax, rbx, rcx, rdx, rsi, rdi, rbp, rsp, r8, r9, r10, r11, r12, r13, r14, r15`寄存器。CPU对这16个通用寄存器的用途没有做特殊规定，程序员和编译器可以自定义其用途（下面会介绍，rsp/rbp寄存器其实是有特殊用途的）；
2. **程序计数寄存器（PC寄存器，有时也叫IP寄存器）**：`rip`寄存器。它用来存放下一条即将执行的指令的地址，这个寄存器决定了程序的执行流程；
3. **段寄存器**：fs和gs寄存器。一般用它来实现线程本地存储（TLS），比如`AMD64` linux平台下go语言和pthread都使用fs寄存器来实现系统线程的TLS，在本章线程本地存储一节和第二章详细分析goroutine调度器的时候我们可以分别看到Linux平台下Pthread线程库和go是如何使用fs寄存器的。

上述这些寄存器除了fs和gs段寄存器是16位的，其它都是64位的，也就是8个字节，其中的16个通用寄存器还可以作为32/16/8位寄存器使用，只是使用时需要换一个名字，比如可以用eax这个名字来表示一个32位的寄存器，它使用的是rax寄存器的低32位。

为了便于查阅，下表列出这些64通用寄存器对应的32/16/8位寄存器的名字：

| 64位   | 32位     | 16位     | 8位      |
| :----- | :------- | :------- | :------- |
| rax    | eax      | ax       | al/ah    |
| rbx    | ebx      | bx       | bl/bh    |
| rcx    | ecx      | cx       | cl/ch    |
| rdx    | edx      | dx       | dl/dh    |
| rsi    | esi      | si       | -        |
| rdi    | edi      | di       | -        |
| rbp    | ebp      | bp       | -        |
| rsp    | esp      | sp       | -        |
| r8~r15 | r8d~r15d | r8w~r15w | r8b~r15b |

通用寄存器的用法如前面我们所见，主要用于临时存放数据，后面的章节我们还会见到大量使用通用寄存器的例子，所以这里就不对其进行详细介绍了，但有三个比较特殊的寄存器值得在这里单独提出来做一下说明：

**rip寄存器**

rip寄存器里面存放的是CPU即将执行的下一条指令在内存中的地址。看如下汇编语言代码片段：

```
0x0000000000400770: add   %rdx,%rax
0x0000000000400773: mov   $0x0,%ecx
```

假设当前CPU正在执行第一条指令，这条指令在内存中的地址是0x0000000000400770，紧接它后面的下一条指令的地址是0x0000000000400773，所以此时rip寄存器里面存放的值是0x0000000000400773。

**这里需要牢记的就是rip寄存器的值不是正在被CPU执行的指令在内存中的地址，而是紧挨这条正在被执行的指令后面那一条指令的地址。**

读者可能会有疑问，在前面的两个汇编指令片段中并没有指令修改rip寄存器的值，是怎么做到让它一直指向下一条即将执行的指令的呢？其实修改rip寄存器的值是CPU自动控制的，不需要我们用指令去修改，当然CPU也提供了几条可以间接修改rip寄存器的指令，在汇编语言一节中我们会详细介绍CPU自动修改以及用指令修改rip寄存器值的两种方式。

**rsp 栈顶寄存器和rbp栈基址寄存器**

这两个寄存器都跟函数调用栈有关，其中rsp寄存器一般用来存放函数调用栈的栈顶地址，而rbp寄存器通常用来存放函数的栈帧起始地址，编译器一般使用这两个寄存器加一定偏移的方式来访问函数局部变量或函数参数，比如：

```
mov    0x8(%rsp),%rdx
```

这条指令把地址为 0x8(%rsp) 的内存中的值拷贝到rdx寄存器，这里的0x8(%rsp) 就利用了 rsp 寄存器加偏移 8 的方式来读取内存中的值。

寄存器的内容我们就先简单的介绍到这里，但这些并不是我们需要了解的有关寄存器的全部内容，有些内容需要等我们学习了汇编指令和函数调用栈之后才能更加深刻的理解，到时候我们再回头来继续介绍相关的知识。

**参考：**

https://mp.weixin.qq.com/s?__biz=MzU1OTg5NDkzOA==&mid=2247483660&idx=1&sn=ea75d8fdb4b2e0eac03449d63172fe3e&scene=19#wechat_redirect