# 逃逸分析
以下调试环境`go1.13.12`
## 1 前言
所谓**逃逸分析**（Escape analysis）是指**由编译器决定内存分配的位置**，不需要程序员指定。 函数中申请一个新的对象

- 如果分配在**栈**中，则函数执行结束可**自动**将内存回收；
- 如果分配在**堆**中，则函数执行结束可交给**GC**（垃圾回收）处理；


有了逃逸分析，返回函数局部变量将变得可能，除此之外，逃逸分析还跟闭包息息相关，了解哪些场景下对象会逃逸至关重要。

## 2 逃逸策略
每当函数中申请新的对象，编译器会根据该对象是否被**函数外部引用**来决定是否逃逸：
1. 如果函数外部没有引用，则优先放到栈中； 
2.  如果函数外部存在引用，则必定放到堆中；

**注意**：对于函数外部没有引用的对象，也有可能放到堆中，比如**内存过大**超过栈的存储能力。



## 3 需要进行逃逸分析的原因

可以反过来想，如果变量都分配到堆上会出现什么事情？例如：

- 垃圾回收（GC）的压力不断增大。
- 申请、分配、回收内存的系统开销增大（相对于栈）。
- 动态分配产生一定量的内存碎片。

总体来说，频繁申请、分配堆内存是有一定“代价”的，会影响应用程序的运行效率，间接影响整个系统。因此，“按需分配”可以最大限度地灵活利用资源，这就是需要做逃逸分析的原因之一。

## 4 逃逸分析方式

第一种，通过编译器提供的命令-gcflags可以看到详细的逃逸分析过程，命令如下：

```
go build -gcflags '-m -l' main.go
```

涉及的参数如下：

- -m：打印逃逸分析的优化策略，最多可以用4个-m，但是需要调试的信息量较大，一般用一个就足够了。
- -l：禁用函数内联，禁用inline可以更好地观察逃逸情况，减少干扰。

第二种，通过反编译命令查看，命令如下：

```
go tool compile -S main.go
# 简单
go tool compile -m main.go
```

注意：可以通过` go tool compile-help` 查看所有允许传递给编译器的标识参数。

## 5 逃逸场景
### 5.1 指针逃逸

我们知道Go可以返回局部变量指针，这其实是一个典型的变量逃逸案例，示例代码如下：
```
package main

type Student struct {
    Name string
    Age  int
}

func StudentRegister(name string, age int) *Student {
    //局部变量s逃逸到堆
    s := new(Student) 
    s.Name = name
    s.Age = age

    return s
}

func main() {
    StudentRegister("Jim", 18)
}
```
函数`StudentRegister()`内部`s`为局部变量，其值通过函数返回值返回，`s`**本身为一指针**，其指向的内存地址不会是栈而是堆，这就是典型的逃逸案例。

通过编译参数`-gcflag=-m`可以查看编译过程中的逃逸分析：

```
>go build -gcflags=-m taoyifenxi.go
# command-line-arguments
.\taoyifengxi.go:8:6: can inline StudentRegister
.\taoyifengxi.go:17:6: can inline main
.\taoyifengxi.go:18:17: inlining call to StudentRegister
.\taoyifengxi.go:8:22: leaking param: name
.\taoyifengxi.go:10:10: new(Student) escapes to heap
.\taoyifengxi.go:18:17: main new(Student) does not escape

```

可见在`StudentRegister()`函数中，也即代码第10行显示`"escapes to heap"`，代表该行内存分配发生了逃逸现象。

### 5.2 栈空间不足逃逸

看下面的代码，是否会产生逃逸呢？
```
package main

func Slice() {
    s := make([]int, 1000, 1000)

    for index, _ := range s {
        s[index] = index
    }
}

func main() {
    Slice()
}
```
上面代码`Slice()`函数中分配了一个1000个长度的切片，**是否逃逸取决于栈空间是否足够大**。 直接查看编译提示，如下：

```
>go build -gcflags=-m taoyifenxi2.go
# command-line-arguments
.\taoyifenxi2.go:11:6: can inline main
.\taoyifenxi2.go:4:11: Slice make([]int, 1000, 1000) does not escape

```
我们发现此处并没有发生逃逸。那么把切片长度扩大10倍即10000会如何呢?
```
>go build -gcflags=-m taoyifenxi2.go
# command-line-arguments
.\taoyifenxi2.go:11:6: can inline main
.\taoyifenxi2.go:4:11: make([]int, 10000, 10000) escapes to heap

```

我们发现当切片长度扩大到10000时就会逃逸。

实际上当**栈空间不足**以存放当前对象时或无法判断当前切片长度时会将对象**分配到堆**中。

### 5.3 动态类型逃逸

很多函数参数为`interface`类型，比如`fmt.Println(a ...interface{})`，编译期间很难确定其参数的具体类型，也会产生逃逸。 如下代码所示：
```
package main

import "fmt"

func main() {
    s := "Escape"
    fmt.Println(s)
}
```
上述代码`s`变量只是一个`string`类型变量，调用`fmt.Println()`时会产生逃逸：

```
>go build -gcflags=-m taoyifenxi3.go
# command-line-arguments
.\taoyifenxi3.go:7:13: inlining call to fmt.Println
.\taoyifenxi3.go:7:13: s escapes to heap
.\taoyifenxi3.go:7:13: main []interface {} literal does not escape
.\taoyifenxi3.go:7:13: io.Writer(os.Stdout) escapes to heap
<autogenerated>:1: (*File).close .this does not escape
<autogenerated>:1: (*File).isdir .this does not escape
```

### 5.4 闭包引用对象逃逸

某著名的开源框架实现了某个返回`Fibonacci`数列的函数：
```
func Fibonacci() func() int {
    a, b := 0, 1
    return func() int {
        a, b = b, a+b
        return a
    }
}
```
该函数返回一个闭包，闭包**引用**了函数的局部变量a和b，使用时通过该函数获取该闭包，然后每次执行闭包都会依次输出`Fibonacci`数列。 完整的示例程序如下所示：

```
package main

import "fmt"

func Fibonacci() func() int {
    a, b := 0, 1
    return func() int {
        a, b = b, a+b
        return a
    }
}

func main() {
    f := Fibonacci()
    for i := 0; i < 10; i++ {
        fmt.Printf("Fibonacci: %d\n", f())
    }
}
```
上述代码通过`Fibonacci()`获取一个闭包，每次执行闭包就会打印一个`Fibonacci`数值。输出如下所示：

```
Fibonacci: 1
Fibonacci: 1
Fibonacci: 2
Fibonacci: 3
Fibonacci: 5
Fibonacci: 8
Fibonacci: 13
Fibonacci: 21
Fibonacci: 34
Fibonacci: 55
```

`Fibonacci()`函数中原本属于局部变量的a和b由于闭包的引用，不得不将二者放到堆上，以致产生逃逸：

```
>go build -gcflags=-m taoyifenxi4.go
# command-line-arguments
.\taoyifenxi4.go:7:9: can inline Fibonacci.func1
.\taoyifenxi4.go:16:13: inlining call to fmt.Printf
.\taoyifenxi4.go:6:2: moved to heap: a
.\taoyifenxi4.go:6:5: moved to heap: b
.\taoyifenxi4.go:7:9: func literal escapes to heap
.\taoyifenxi4.go:16:34: f() escapes to heap
.\taoyifenxi4.go:16:13: main []interface {} literal does not escape
.\taoyifenxi4.go:16:13: io.Writer(os.Stdout) escapes to heap
<autogenerated>:1: (*File).close .this does not escape
<autogenerated>:1: (*File).isdir .this does not escape

```
## 6 逃逸总结
- 栈上分配内存比在堆中分配内存有更高的效率
- 栈上分配的内存不需要GC处理
- 堆上分配的内存使用完毕会交给GC处理
- 逃逸分析目的是决定内分配地址是栈还是堆
- 逃逸分析在编译阶段完成
-  每个Go版本的逃逸分析都有所不同（会改变，会优化）
## 7 编程Tips
思考一下这个问题：函数传递指针真的比传值效率高吗？ 我们知道传递指针可以减少底层值的拷贝，可以提高效率，但是如果拷贝的数据量小，由于指针传递会产生逃逸，可能会使用堆，也可能会增加GC的负担，所以传递指针不一定是高效的。