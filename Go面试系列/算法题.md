## 面试必备算法

### 实现 Sunday 匹配

### 01、实现 strStr()

题目：实现 strStr()

实现 strStr() 函数。给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字
符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。
示例 1:

```
输入: haystack = "hello", needle = "ll" 输出: 2
```

示例 2:

```
输入: haystack = "aaaaa", needle = "bba" 输出: -1
```

说明:
当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。
对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及
Java的 indexOf() 定义相符。

### 02、Sunday 匹配

Sunday 算法是 Daniel M.Sunday 于1990年提出的字符串模式匹配。其核心思想是：
在匹配过程中，模式串发现不匹配时，算法能跳过尽可能多的字符以进行下一步的匹
配，从而提高了匹配效率。


#### 因为该问是字符串匹配篇第一讲，所以先普及几个概念：

####  串：串是字符串的简称

####  空串：⻓度为零的串称为空串

####  主串：包含子串的串相应地称为主串

####  子串：串中任意个连续字符组成的子序列称为该串的子串

####  模式串：子串的定位运算又称为串的模式匹配，是一种求子串第一个字符在主串中

#### 序号的运算。被匹配的主串称为目标串，子串称为模式串。

了解这些基本概念，回到这个算法。Sunday匹配不是说这人在周末发现了这个算法，而
是这人名字叫星期天（可能父母总加班，所以起了这么个名）。听起来牛叉的不得了，
其实是个啥意思：
假若我们的目标串为：Here is a little Hao
模式串为：little
一般来讲，字符串匹配算法第一步，都是把目标串和模式串对⻬。不管是KMP，BM，
SUNDAY都是这样。

#### 而对于SUNDAY算法，我们从头部开始比较，一旦发现不匹配，直接找到主串中位于模

式串后面的第一个字符，即下面绿色的 “s”。（这里说明一下，为什么是找模式串后面
的第一个字符。在把模式串和目标串对⻬后，如果发现不匹配，那肯定需要移动模式
串。问题是需要移动多少步。各字符串匹配算法之间的差别也来自于这个地方，对于
KMP，是建立部分匹配表来计算。BM，是反向比较计算移动量。对于SUNDAY，就是
找到模式串后的第一个字符。因为，无论模式串移动多少步，模式串后的第一个字符都
要参与下一次比较，也就是这里的 “s”）

找到了模式串后的第一个字符 “s”，接下来该怎么做？我们需要查看模式串中是否包含
这个元素，如果不包含那就可以跳过一大片，从该字符的下一个字符开始比较。

因为仍然不匹配（空格和l），我们继续重复上面的过程。找到模式串的下一个元素：t


```
现在有意思了，我们发现 t 被包含于模式串中，并且 t 出现在模式串倒数第3个。所以
我们把模式串向前移动3个单位：
```

#### 有内味了，我们发现竟然匹配成功了，是不是很神奇？证明的过程今天暂且不谈（后面

#### 我会出一个算法证明篇，来证明之前讲过的一些算法。我需要你做的是，掌握上面这

#### 些！）

#### 捞干货，这个过程里我们做了一些什么：

####  对⻬目标串和模式串，从前向后匹配

####  关注主串中位于模式串后面的第一个元素（核心）

####  如果关注的字符没有在子串中出现则直接跳过

####  否则开始移动模式串，移动位数 = 子串⻓度 - 该字符最右出现的位置(以0开始)

### 03、算法应用

#### 自然是把这个算法应用到我们的题目中咯...

```
根据分析，得出代码：（给一个保证你能看的懂的Golang版本的）
1 func strStrSunday(haystack, needle string) int {
2 //先判断两个字符串的合法性
```

(^3) if len(haystack) < len(needle) {
(^4) return -1
(^5) }
(^6) if haystack == needle {
(^7) return 0
(^8) }
9 //定义最终位置的索引
10 index := -1
(^11) i := 0
(^12) //定义目标匹配索引
(^13) needleIndex := 0
(^14) for i < len(haystack) {
(^15) //逐字节判断是否相等
(^16) if haystack[i] == needle[needleIndex] {
17 //只有当index为-1时，说明是首次匹配到字符
18 if index == -1 {


### 反转字符串(301)

### 01、题目分析

### 第344题：反转字符串

```
编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形
式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的
额外空间解决这一问题。
```

19 index = i
20 }

(^21) //主串索引和模式串索引都自增
(^22) i++
(^23) needleIndex++
(^24) //判断是否完成匹配
(^25) if needleIndex >= len(needle) {
26 break
27 }
28 continue
(^29) }
(^30) //走到这里说明没有匹配成功，将匹配目标索引置为默认
(^31) index = -1
(^32) //计算主串需要移动的位置
(^33) i = i + len(needle) - needleIndex
(^34) //如果主串索引大于了主串实际长度则返回
35 if i >= len(haystack) {
36 return index
37 }
(^38) //计算下一个字符在模式串最右的位置
(^39) offset := 1
(^40) for j := len(needle) - 1; j > 0; j-- {
(^41) if haystack[i] == needle[j] {
(^42) offset = j
43 break
44 }
45 }
(^46) //将主串的索引左移指定长度，使当前的字符和模式串中最右匹配到的字符串对齐
(^47) i = i - offset
(^48) //将模式串的索引重置
(^49) needleIndex = 0
(^50) }
(^51) return index
52 }


#### 示例 1：

```
输入：["h","e","l","l","o"] 输出：["o","l","l","e","h"]
示例 2：
输入：["H","a","n","n","a","h"] 输出：["h","a","n","n","a","H"]
```

### 02、题目图解

#### 这是一道相当简单的经典题目，直接上题解：使用双指针进行反转字符串。

```
假设输入字符串为["h","e","l","l","0"]
 定义left和right分别指向首元素和尾元素
 当left < right ，进行交换。
 交换完毕， left++，right--
 直至 left == right
具体过程如下图所示：
```

### 03、Go语言示例

#### 根据以上分析，我们可以得到下面的题解：

1 func Reverse(s []byte) {
2 right := len(s) - 1


```
原文
反转字符串(301)
```

### 字符串中的第一个唯一字符

### 01、题目分析

### 第387题：字符串中的第一个唯一字符

#### 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返

#### 回 -1 。 案例:

```
s = "leetcode" 返回 0.
s = "loveleetcode", 返回 2.
注意事项： 您可以假定该字符串只包含小写字母。
常考题目，建议自行思考 1-2 分钟先～
```

### 02、题目图解

#### 题目不难，直接进行分析。由于字母共有 26 个，所以我们可以声明一个 26 个⻓度的

#### 数组（该种方法在本类题型很常用）因为字符串中字母可能是重复的，所以我们可以先

#### 进行第一次遍历，在数组中记录每个字母的最后一次出现的所在索引。然后再通过一次

#### 循环，比较各个字母第一次出现的索引是否为最后一次的索引。如果是，我们就找到了

#### 我们的目标，如果不是我们将其设为 -1（标示该元素非目标元素）如果第二次遍历最

#### 终没有找到目标，直接返回 -1即可。

#### 图解如下：

```
3 left := 0
45 for left < right {
```

(^6) s[left], s[right] = s[right], s[left]
(^7) left++
(^8) right--
(^9) }
(^10) }


### 03、GO语言示例

#### 根据以上分析，可以得到代码如下：

### 验证回文串

### 01、题目示例

```
⻅微知著，发现一组数据很有趣，分享给大家。leetcode 第一题通过次数为
993,335，第二题通过次数为 396,160，第三题通过次数为 69,508。我想说什么，
请自己悟。
```

```
1 func firstUniqueChar(s string) int {
```

(^2) var arr [26]int
(^3) //第一次遍历计算所有字符出现的最后位置
(^4) for i, k := range s {
(^5) //因为 26 个字母从a开始，减去a则索引会从 0 开始
6 arr[k-'a'] = i
7 }
8 for i, k := range s {
(^9) if arr[k-'a'] == i {
(^10) return i
(^11) }
(^12) }
(^13) return -1
14 }


### 第125题：验证回文串

#### 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小

#### 写。

#### 说明： 本题中，我们将空字符串定义为有效的回文串。

```
示例 1: 输入: "A man, a plan, a canal: Panama" 输出: true
示例 2: 输入: "race a car" 输出: false
```

### 02、图解教程

#### 经典题目，你需要像掌握反转字符串一样掌握本题。

#### 首先，我想确保你知道什么是回文串。“回文串”是一个正读和反读都一样的字符串，比

```
如“level”或者“noon”等等就是回文串。
对于字符串中可能存在的其他字符，可以通过正则替换，但是正则替换会增加程序运行
复杂度，下面给出的是在判断过程中忽略其他字符：
1 func isPalindrome(s string) bool {
2 if s == "" {
3 return false
```

(^4) }
(^5) s = strings.ToLower(s)
(^6) if len(s) == 2 {
(^7) return s[0] == s[1]
(^8) }
(^9) left := 0
10 right := len(s) - 1
11 for left < right {
12 //忽略除字母和数字之外的字符
if !((s[left] >= 'a' && s[left] <= 'z') || (s[left] >= '0' &&
s[left] <= '9')) {
13
(^14) left++
(^15) continue
(^16) }
if !((s[right] >= 'a' && s[right] <= 'z') || (s[right] >= '0' &&
s[right] <= '9')){
17
18 right--
(^19) continue
(^20) }
(^21) if s[left] != s[right] {
(^22) return false
(^23) }
(^24) left++
25 right--
26 }


### 滑动窗口最大值

### 01、题目分析

### 第239题：滑动窗口最大值

```
给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只
可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大
值。
返回滑动窗口中的最大值所构成的数组。
示例:
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 输出: [3,3,5,5,6,7] 解释:
滑动窗口的位置 最大值
```

```
[1 3 -1] -3 5 3 6 7 3
1 [3 -1 -3] 5 3 6 7 3
1 3 [-1 -3 5] 3 6 7 5
1 3 -1 [-3 5 3] 6 7 5
1 3 -1 -3 [5 3 6] 7 6
1 3 -1 -3 5 [3 6 7] 7
```

### 02、题目分析

```
本题对于题目没有太多需要额外说明的，应该都能理解，直接进行分析。我们很容易想到，可
以通过遍历所有的滑动窗口，找到每一个窗口的最大值，来进行暴力求解。那一共有多少个滑
动窗口呢，小学题目，可以得到共有 L-k+1 个窗口。
假设  nums = [1,3,-1,-3,5,3,6,7] ，和  k = 3 ，窗口数为 6 :
```

27 return true
28 }


```
根据分析，直接完成代码：
1 func maxSlidingWindow(nums []int, k int) []int {
```

(^2) l1 := len(nums)
(^3) index := 0
4 ret := make([]int, 0)
5 for index < l1 {
6 m := nums[index]
(^7) if index > l1 - k {
(^8) break
(^9) }
(^10) for j := index + 1; j < index + k; j++ {
(^11) if m < nums[j] {
(^12) m = nums[j]
13 }
14 }
(^15) ret = append(ret,m)
(^16) index++
(^17) }
(^18) return ret
(^19) }


### 03、线性题解

这里不卖关子，其实这道题比较经典，我们可以采用队列，DP，堆等方式进行求解，所有思
路的主要源头应该都是在窗口滑动的过程中，如何更快的完成查找最大值的过程。但是最典型
的解法还是使用双端队列。具体怎么来求解，一起看一下。
首先，我们了解一下，什么是双端队列：是一种具有队列和栈的性质的数据结构。双端队列中
的元素可以从两端弹出或者插入。

我们可以利用双端队列来实现一个窗口，目的是让该窗口可以做到张弛有度（汉语博大精深，
也就是⻓度动态变化。其实用游标或者其他解法的目的都是一样的，就是去维护一个可变⻓的
窗口）
然后我们再做一件事，只要遍历该数组，同时**在双端队列的头去维护当前窗口的最大值（在
遍历过程中，发现当前元素比队列中的元素大，就将原来队列中的元素祭天），在整个遍历的
过程中我们再记录下每一个窗口的最大值到结果数组中。**最终结果数组就是我们想要的，整
体图解如下。
假设  nums = [1,3,-1,-3,5,3,6,7] ，和  k = 3 :


```
根据分析，得出代码：
```

## 排序算法

### 冒泡排序

```
冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数
列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重
复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是
因为越小的元素会经由交换慢慢“浮”到数列的顶端。
作为最简单的排序算法之一，冒泡排序给我的感觉就像 Abandon 在单词书里出现的感
觉一样，每次都在第一⻚第一位，所以最熟悉。冒泡排序还有一种优化算法，就是立一
```

```
1 func maxSlidingWindow2(nums []int, k int) []int {
2 ret := make([]int,0)
3 if len(nums) == 0 {
```

(^4) return ret
(^5) }
(^6) var queue []int
(^7) for i := range nums {
(^8) for i > 0 && (len(queue) > 0) && nums[i] > queue[len(queue)-1] {
(^9) //将比当前元素小的元素祭天
10 queue = queue[:len(queue)-1]
11 }
12 //将当前元素放入queue中
(^13) queue = append(queue, nums[i])
(^14) if i >= k && nums[i-k] == queue[0] {
(^15) //维护队列，保证其头元素为当前窗口最大值
(^16) queue = queue[1:]
(^17) }
18 if i >= k-1 {
19 //放入结果数组
20 ret = append(ret, queue[0])
(^21) }
(^22) }
(^23) return ret
(^24) }


```
个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进
对于提升性能来说并没有什么太大作用。
```

### 1. 算法步骤

#### 比较相邻的元素。如果第一个比第二个大，就交换他们两个。

#### 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后

#### 的元素会是最大的数。

#### 针对所有的元素重复以上的步骤，除了最后一个。

#### 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

### 2. 动图演示

### 3. 最慢和最快

#### 正序时最快，反序时最慢

### Golang实现

1 func bubbleSort(arr []int) []int {
2 if len(arr) == 0 {
3 return arr


### 选择排序

```
选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所
以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了
吧。
```

### 1. 算法步骤

####  首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置

####  再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。

####  重复第二步，直到所有元素均排序完毕。

### 2. 动图演示

### 3. Go 代码实现

```
4 }
5 for i := 0; i < len(arr); i++ {
```

(^6) for j := 0; j < len(arr); j++ {
(^7) if arr[i] > arr[j] {
(^8) arr[j], arr[i] = arr[i], arr[j]
(^9) }
(^10) }
11 }
12 return arr
13 }
1 func selectionSort(arr []int) []int {
(^2) l := len(arr)
(^3) if l == 0 {
(^4) return arr
(^5) }
(^6) for i := 0; i < l; i++ {
7 min := i
8 for j := i + 1; j < l; j++ {


9 if arr[j] < arr[min] {
10 min = j

(^11) }
(^12) }
(^13) arr[i],arr[min] = arr[min],arr[i]
(^14) }
(^15) return arr
16 }

