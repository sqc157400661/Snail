# 希尔排序

1959 年一个叫 `Donald L. Shell (March 1, 1924 – November 2, 2015)`的美国人在 `Communications of the ACM` 国际计算机学会月刊 发布了一个排序算法，从此名为希尔排序的算法诞生了。

注： `ACM = Association for Computing Machinery`，国际计算机学会，世界性的计算机从业员专业组织，创立于1947年，是世界上第一个科学性及教育性计算机学会。

**希尔排序是直接插入排序的改进版本**。因为直接插入排序对那些几乎已经排好序的数列来说，排序效率极高，达到了 O(n) 的线性复杂度，但是每次只能将数据移动一位。希尔排序创造性的可以将数据移动 n 位，然后将 n 一直缩小，缩到与直接插入排序一样为 1，请看下列分析。

**希尔排序属于插入类排序算法**。

## 一、算法介绍

有一个 N 个数的数列：

1. 先取一个小于 N 的整数 d1，将位置是 d1 整数倍的数们分成一组，对这些数进行直接插入排序。
2. 接着取一个小于 d1 的整数 d2，将位置是 d2 整数倍的数们分成一组，对这些数进行直接插入排序。
3. 接着取一个小于 d2 的整数 d3，将位置是 d3 整数倍的数们分成一组，对这些数进行直接插入排序。
4. ...
5. 直到取到的整数 d=1，接着使用直接插入排序。 这是一种分组插入方法，最后一次迭代就相当于是直接插入排序，其他迭代相当于每次移动 n 个距离的直接插入排序，这些整数是两个数之间的距离，我们称它们为增量。

![file](http://cdn.xiaot123.com/blog/2020-07/1700076-20191022214656603-1520311781.png-blog?ynotemdtimestamp=1610262092546)

我们取数列**长度的一半**为**增量**，以后每次减半，直到增量为1。

举个简单例子，希尔排序一个 12 个元素的数列：`[5 9 1 6 8 14 6 49 25 4 6 3]`，增量 d 的取值依次为：`6，3，1`：

```
x 表示不需要排序的数

取 d = 6 对 [5 x x x x x 6 x x x x x] 进行直接插入排序，没有变化。
取 d = 3 对 [5 x x 6 x x 6 x x 4 x x] 进行直接插入排序，排完序后：[4 x x 5 x x 6 x x 6 x x]。
取 d = 1 对 [4 9 1 5 8 14 6 49 25 6 6 3] 进行直接插入排序，因为 d=1 完全就是直接插入排序了。
```

越有序的数列，直接插入排序的效率越高，希尔排序通过分组使用直接插入排序，因为步长比 1 大，在一开始可以很快将无序的数列变得不那么无序，比较和交换的次数也减少，直到最后使用步长为 1 的直接插入排序，数列已经是相对有序了，所以时间复杂度会稍好一点。

## 二、算法实现

```
package main

import "fmt"

// 增量序列折半的希尔排序
func ShellSort(list []int) {
    // 数组长度
    n := len(list)

    // 每次减半，直到步长为 1
    for step := n / 2; step >= 1; step /= 2 {
        // 开始插入排序，每一轮的步长为 step
        for i := step; i < n; i += step {
            for j := i - step; j >= 0; j -= step {
                // 满足插入那么交换元素
                if list[j+step] < list[j] {
                    list[j], list[j+step] = list[j+step], list[j]
                    continue
                }
                break
            }
        }
    }
}

func main() {
    list := []int{5}
    ShellSort(list)
    fmt.Println(list)

    list1 := []int{5, 9}
    ShellSort(list1)
    fmt.Println(list1)

    list2 := []int{5, 9, 1, 6, 8, 14, 6, 49, 25, 4, 6, 3}
    ShellSort(list2)
    fmt.Println(list2)

    list3 := []int{5, 9, 1, 6, 8, 14, 6, 49, 25, 4, 6, 3, 2, 4, 23, 467, 85, 23, 567, 335, 677, 33, 56, 2, 5, 33, 6, 8, 3}
    ShellSort(list3)
    fmt.Println(list3)
}
```

按照之前分析的几种排序算法，一般建议待排序数组为小规模情况下使用直接插入排序，在规模中等的情况下可以使用希尔排序，但在大规模还是要使用快速排序，归并排序或堆排序。