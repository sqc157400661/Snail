## 题目描述：

数字1～1000放在含有1001个元素的数组中，其中只有唯一的一个元素值重复，其他数字均只出现一次。设计一个算法，将重复元素找出来，要求每个数组元素只能访问一次。如果不使用辅助存储空间，能否设计一个算法实现？

hash法、求和法、异或法就不介绍了

## 方法一：数据映射法

数组取值操作可以看作一个特殊的函数 f:D→R，定义域为下标值 0～1000，值域为 1到1000。如果对任意一个数 i，把f(i)称为它的后继，i称为f(i)的前驱。0只有后继，没有前驱，其他数字既有后继也有前驱，重复的那个数字有两个前驱，将利用这些特征。

采用此种方法，可以发现一个规律，即从 0 开始画一个箭头指向它的后继，从它的后继继续指向后继的后继，这样，必然会有一个结点指向之前已经出现过的数，即为重复的数。

利用下标与单元中所存储的内容之间的特殊关系，进行遍历访问单元，一旦访问过的单元赋予一个标记（把数组中元素变为它的相反数），利用标记作为发现重复数字的关键。

以数组`array={1， 3， 4， 3， 5， 2}`为例。从下标0开始遍历数组，

1. `array[0]`的值为1，说明没有被遍历过，接下来遍历下标为1的元素，同时标记已遍历过的元素（变为相反数）：`array={-1， 3， 4， 3， 5， 2}`。
2. `array[1]`的值为3，说明没被遍历过，接下来遍历下标为3的元素，同时标记已遍历过的元素：`array={-1，-3， 4， 3， 5， 2}`。
3. `array[3]`的值为3，说明没被遍历过，接下来遍历下标为3的元素，同时标记已遍历过的元素：`array={-1，-3， -4， -3， 5， 2}`
4. `array[3]`的值为-3，说明3已经被遍历过了，找到了重复的元素。

示例代码如下：

```
package main

import "fmt"

func main(){
	arr := []int{1,3,4,2,5,4}
	fmt.Println("数据映射法")
	fmt.Println(FindDupByMap(arr))
}
func FindDupByMap(arr []int) (int) {
	if arr == nil {
		return -1
	}
	len :=len(arr)
	index := 0
	for i:=0;i< len;i++ {
		// 数组中元素的值，只能小于len，否则会溢出
		if arr[index] >=len {
			return -1
		}
		if arr[index]<0{
			break
		}
		// 访问过，通过变相番薯的方法进行标记
		arr[index] *= -1
		fmt.Println(arr[index])
		// index的后继为array[index]
		index = arr[index] * -1
		if index >= len {
			fmt.Println("数组中有非法数字")
			return -1
		}
	}
	return index
}
```

### 算法性能分析：

上述方法的时间复杂度为O(n)，也没有申请辅助的存储空间。

这种方法的缺点是修改了数组中元素的值，当然也可以在找到重复元素之后对数组进行一次遍历，把数组中的元素改为它的绝对值的方法来恢复对数组的修改。

## 方法二：环形相遇法

- 该方法就是采用类似于单链表是否存在环的方法进行问题求解。
- “判断单链表是否存在环”是一个非常经典的问题，同时单链表可以采用数组实现，此时每个元素值作为next指针指向下一个元素。
- 本题可以转化为“已知一个单链表中存在环，找出环的入口点”这种想法。
- 具体思路如下：将`array[i]`看作第i个元素的索引，即：`array[i]->array[array[i]]->array [array[array[i]]]->array[array[array[array[i]]]]->…`最终形成一个单链表，由于数组a中存在重复元素，则一定存在一个环，**且环的入口元素即为重复的元素**。

该题的关键在于，数组array的大小是n，而元素的范围是`[1，n-1]`，所以，`array[0]`不会指向自己，进而不会陷入错误的自循环。如果元素的范围中包含 0，则该题不可直接采用该方法。以数组序列`{1， 3， 4， 2， 5， 3}`为例。

按照上述规则，这个数组序列对应的单链表如下图所示：

![file](http://cdn.xiaot123.com/blog/2020-07/wx_20200721170242.png-blog?ynotemdtimestamp=1610262092546)

从上图可以看出这个链表有环，且环的入口点为3，所以，这个数组中重复元素为3。

在实现的时候可以参考求单链表环的入口点的算法：

- 用两个速度不同的变量 slow 和fast 来访问，其中，slow 每次前进一步，fast 每次前进两步。
- 在有环结构中，它们总会相遇。接着从数组首元素与相遇点开始分别遍历，每次各走一步，它们必定相遇，且相遇第一点为环入口点。

示例代码如下：

```
package main

import "fmt"

func main() {
	arr := []int{1, 3, 4, 2, 5, 4}
	fmt.Println("环形相遇法")
	fmt.Println(FindDupByLoop(arr))
}
func FindDupByLoop(arr []int) int {
	if arr == nil {
		return -1
	}
	slow := 0
	fast := 0
	for ok := true; ok; ok = slow != fast {
		fast = arr[arr[fast]]
		slow = arr[slow]
	}
	head := 0
	// 找到入口点
	for ok := true; ok; ok = slow != head {
		head = arr[head]
		slow = arr[slow]
	}
	return slow
}
```

## 算法性能分析：

上述方法的时间复杂度为O(n)，也没有申请辅助的存储空间。

当数组中的元素不合理的时候，上述算法有可能会有数组越界的可能性，因此，为了安全性和健壮性，可以在执行`fast=array[array[fast]];slow=array[slow]`;操作的时候分别检查`array[slow]`与`array[fast]`的值是否会越界，如果越界，则说明提供的数据不合法。