# 数组和切片

## (1) 切片的初始化与追加

> 写出程序运行的结果

```
package main

import (
    "fmt"
)

func main(){
    s := make([]int, 10)

    s = append(s, 1, 2, 3)

    fmt.Println(s)
}
```

**考点**

切片追加, make初始化均为0

**结果**

```
[0 0 0 0 0 0 0 0 0 0 1 2 3]
```

## (2) slice拼接问题

下面是否可以编译通过？

```
package main

import "fmt"

func main() {
	s1 := []int{1, 2, 3}
	s2 := []int{4, 5}
	s1 = append(s1, s2)
	fmt.Println(s1)
}
```

**结果**

编译失败

两个slice在append的时候，记住需要进行将第二个slice进行`...`打散再拼接。

```
s1 = append(s1, s2...)
```

## (3) slice中new的使用

下面代码是否可以编译通过？

```
package main

import "fmt"

func main() {
  
	list := new([]int)
  
	list = append(list, 1)
  
	fmt.Println(list)
}
```

**结果**：

编译失败，`./test9.go:9:15: first argument to append must be slice; have *[]int`

**分析**：

> 切片指针的解引用。

> 可以使用`list:=make([]int,0)` list类型为切片

> 或使用`*list = append(*list, 1) `list类型为指针

**new和make的区别：**

 二者都是内存的分配（堆上），但是make只用于slice、map以及channel的初始化（非零值）；而new用于类型的内存分配，并且内存置为零。所以在我们编写程序的时候，就可以根据自己的需要很好的选择了。

 make返回的还是这三个引用类型本身；而new返回的是指向类型的指针。

